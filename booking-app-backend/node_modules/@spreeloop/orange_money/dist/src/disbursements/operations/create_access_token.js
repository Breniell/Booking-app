"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAccessToken = void 0;
const https_1 = require("../../utils/https");
const disbursement_service_1 = require("../implementations/disbursement_service");
/**
 * Creates an access token.
 *
 * @param {CreateAccessTokenRequest} configs - The disbursement service config.
 * @param {string} endPoint - The end point.
 * @return {CreateAccessTokenResponse} The method response containing the access token and raw response.
 */
async function createAccessToken({ configs, endPoint, }) {
    const logger = configs.logger;
    logger.info('createAccessToken is running ...');
    const { error: configsValidationError, value: configValues } = disbursement_service_1.DisbursementServiceConfigSchema.validate(configs);
    if (configsValidationError) {
        logger.error(`Invalid DisbursementServiceConfig request parameters. params : ${JSON.stringify(configsValidationError.details)}`);
        return { error: configsValidationError.details };
    }
    const authorization = (0, https_1.hash)(configValues.clientId, configValues.clientSecret);
    const headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
        Authorization: `Basic ${authorization}`,
    };
    const body = (0, https_1.encodeDataToXFormUrl)({
        grant_type: 'client_credentials',
    });
    const response = await (0, https_1.postRequest)({
        logger: logger,
        route: endPoint,
        data: body,
        headers: headers,
        rejectUnauthorized: false,
    });
    if (!response.response) {
        return { error: response.error };
    }
    return {
        data: response.response.data.access_token,
        raw: response.response.data,
    };
}
exports.createAccessToken = createAccessToken;
//# sourceMappingURL=create_access_token.js.map