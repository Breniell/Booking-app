"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSuccessfulCodeResponse = exports.encodeDataToXFormUrl = exports.encodeToBase64 = exports.encodeTheBodyOfRequest = exports.hash = exports.parseAxiosError = exports.getRequest = exports.postRequest = exports.RequestStatusCode = void 0;
const axios = __importStar(require("axios"));
const axios_1 = require("axios");
const base64url_1 = __importDefault(require("base64url"));
const https = __importStar(require("https"));
var RequestStatusCode;
(function (RequestStatusCode) {
    RequestStatusCode[RequestStatusCode["unauthorized"] = 401] = "unauthorized";
    RequestStatusCode[RequestStatusCode["expectationFailed"] = 417] = "expectationFailed";
})(RequestStatusCode = exports.RequestStatusCode || (exports.RequestStatusCode = {}));
/**
 * Posts an http request to the given route.
 * @param {Record<string, string | undefined> | string} data The data to be posted.
 * @param {string} route The end point url.
 * @param {Record<string, string>} headers The type content  of request.
 * @param {LoggerInterface} logger The logger to use when posting data.
 * @return {Promise<unknown | undefined>} The server response.
 */
async function postRequest({ data, route, headers, logger, rejectUnauthorized = true, }) {
    try {
        logger.info(`Request on the route ${route} is running with data : ${JSON.stringify({
            headers,
            data,
            route,
        })}`);
        const agent = new https.Agent({
            rejectUnauthorized: rejectUnauthorized,
        });
        const response = await axios.default({
            method: 'post',
            url: route,
            headers: headers,
            data: data,
            httpsAgent: agent,
        });
        logger.info(`Request on the route ${route} completed successfully with data : ${JSON.stringify({
            response: response.data,
            status: response.status,
            statusText: response.statusText,
        })}`);
        return { response: { data: response.data, status: response.status } };
    }
    catch (error) {
        logger.warn(`[Axios] failed to post request on the route: ${route} with data : ${JSON.stringify({ headers, data, route })}`);
        const parsedError = parseAxiosError(error);
        logger.warn(JSON.stringify(error));
        if (error instanceof axios_1.AxiosError) {
            if (error.response) {
                return {
                    response: {
                        status: error.response.status,
                        data: error.response.data,
                    },
                    error: parsedError,
                };
            }
        }
        return { error: parsedError };
    }
}
exports.postRequest = postRequest;
/**
 * Gets an http request to the given route.
 * @param {Record<string, string | undefined> | string} data The data to be posted.
 * @param {string} route The end point url.
 * @param {Record<string, string>} headers The type content  of request.
 * @param {LoggerInterface} logger The logger to use when getting data.
 * @return {Promise<unknown | undefined>} The server response.
 */
async function getRequest({ data, route, headers, logger, rejectUnauthorized = true, }) {
    try {
        logger.info(`Request on the route ${route} is running with data : ${JSON.stringify({
            headers,
            data,
            route,
        })}`);
        const agent = new https.Agent({
            rejectUnauthorized: rejectUnauthorized,
        });
        const response = await axios.default({
            method: 'get',
            url: route,
            headers: headers,
            data: data,
            httpsAgent: agent,
        });
        logger.info(`Request on the route ${route} completed successfully with data : ${JSON.stringify({
            response: response.data,
            status: response.status,
            statusText: response.statusText,
        })}`);
        return { response: { data: response.data, status: response.status } };
    }
    catch (error) {
        logger.warn(`[Axios] failed to get request on the route: ${route} with data : ${JSON.stringify({ headers, data, route })}`);
        const parsedError = parseAxiosError(error);
        logger.warn(JSON.stringify(error));
        if (error instanceof axios_1.AxiosError) {
            if (error.response) {
                return {
                    response: {
                        status: error.response.status,
                        data: error.response.data,
                    },
                    error: parsedError,
                };
            }
        }
        return { error: parsedError };
    }
}
exports.getRequest = getRequest;
/**
 * Parses an Axios error and returns a modified error object.
 *
 * @param {unknown} error - The error object to be parsed.
 * @return {unknown} The modified error object.
 */
function parseAxiosError(error) {
    var _a, _b;
    let err = error;
    if (error instanceof axios_1.AxiosError) {
        if (error.response) {
            err = {
                responseError: {
                    data: error.response.data,
                    status: error.response.status,
                    statusText: error.response.statusText,
                    headers: error.response.headers,
                },
                requestBody: error.request.body,
            };
        }
        else if (error.request) {
            err = {
                requestFailed: {
                    headers: (_a = error.config) === null || _a === void 0 ? void 0 : _a.headers,
                    data: (_b = error.config) === null || _b === void 0 ? void 0 : _b.data,
                },
            };
        }
        else {
            err = {
                configFailed: error.message,
            };
        }
    }
    return err;
}
exports.parseAxiosError = parseAxiosError;
/**
 * Generates a hash using the given key and secret.
 *
 * @param {string} key - The key to be hashed.
 * @param {string} secret - The secret to be hashed.
 * @return {string} - The generated hash.
 */
function hash(key, secret) {
    const toHash = `${key}:${secret}`;
    if (!global.btoa) {
        return Buffer.from(toHash).toString('base64');
    }
    return global.btoa(toHash);
}
exports.hash = hash;
/**
 * Encode the body of the request.
 * @param {Record<string, string>} bodyRequest the body request.
 * @return {string} the encoded body request result.
 */
function encodeTheBodyOfRequest(bodyRequest) {
    const formBody = [];
    for (const key in bodyRequest) {
        if ({}.hasOwnProperty.call(bodyRequest, key)) {
            const encodedKey = encodeURIComponent(key);
            const encodedValue = encodeURIComponent(bodyRequest[key]);
            formBody.push(encodedKey + '=' + encodedValue);
        }
    }
    return formBody.join('&');
}
exports.encodeTheBodyOfRequest = encodeTheBodyOfRequest;
// Encode to base64
const encodeToBase64 = (apiUsername, apiPassword) => {
    return (0, base64url_1.default)(`${apiUsername}:${apiPassword}`);
};
exports.encodeToBase64 = encodeToBase64;
/**
 * Encode the data to w3 x form encoded url.
 * @param {Record<string, string>} data the data to encode.
 * @return {string} the encoded value.
 */
function encodeDataToXFormUrl(data) {
    const segments = [];
    for (const key in data) {
        if (Object.hasOwnProperty.call(data, key)) {
            const encodedKey = encodeURIComponent(key);
            const encodedValue = encodeURIComponent(data[key]);
            segments.push(`${encodedKey}=${encodedValue}`);
        }
    }
    return segments.join('&');
}
exports.encodeDataToXFormUrl = encodeDataToXFormUrl;
/**
 * Checks if the code is a successful code response.
 * @param {num} code .
 * @return {boolean} true if the code is valid.
 */
const isSuccessfulCodeResponse = (code) => code >= 200 && code < 300;
exports.isSuccessfulCodeResponse = isSuccessfulCodeResponse;
//# sourceMappingURL=https.js.map